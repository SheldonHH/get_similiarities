if ( !working_area_initialized_6 ) 
working_5[ii] = 0; 
working_area_initialized_6 = 1; 
queue_4[0] = pos; 
working_5[pos] = strength; 
iia = queue_4[queue_start]; 
current_strength = inv_attenuation * working_5[iia] / 4096; 
if ( !working_5[delta[d] + iia] ) 
queue_4[queue_end++] = iia + delta[d]; 
working_5[delta[d] + iia] += contribution; 
if ( !working_5[delta[d] + iia] ) 
queue_4[queue_end++] = iia + delta[d]; 
working_5[delta[d] + iia] += contribution_0; 
iib = queue_4[k]; 
if ( working_5[iib] > 81 || !influence[iib] ) 
influence[iib] += working_5[iib]; 
working_5[iib] = 0; 
v0 = &byte_4E235E; 
v4 = ( const char *)&unk_4D382E; 
if ( cached_board_2[ii] != board[ii] ) 
cached_board_2[ii] = board[ii]; 
active_caches_1[k] = 0; 
if ( active_caches_1[color == 1] ) 
escape_value[iia] = escape_values_0[2 * iia + ( color == 1)]; 
escape_values_0[2 * iic + ( color == 1)] = escape_value[iic]; 
active_caches_1[color == 1] = 1; 
memcpy( q, base, sizeof( influence_data)); 
snames_0[dragon[pos].crude_status], 
worms_2[pos][k] = 0; 
worms_2[pos][0] = worm[pos].origin; 
if ( worms_2[pos][l] == worms_2[pos2][k] ) 
if ( worms_2[pos][l] == worms_2[pos2][k] ) 
worms_2[pos][nworms[pos]++] = worms_2[pos2][k]; 
worms_2[pos][nworms[pos]++] = worms_2[pos2][k]; 
w = worms_2[pos][k]; 
( *cw)[4 * pos + k] = worms_2[pos][k]; 
memcpy( &owl_stack[++owl_stack_pointer], *owl, sizeof( local_owl_data)); 
if ( !mx_initialized_1 ) 
memset( mx_0, 0, sizeof( mx_0)); 
memset( mx_0, 0, sizeof( mx_0)); 
mx_initialized_1 = 1; 
mx_0[ii] = 1; 
&& !mx_0[ii + 20] 
mx_0[ii + 20] = 1; 
&& !mx_0[ii - 1] 
mx_0[ii - 1] = 1; 
&& !mx_0[ii - 20] 
mx_0[ii - 20] = 1; 
&& !mx_0[ii + 1] 
mx_0[ii + 1] = 1; 
&& !mx_0[ii + 19] 
mx_0[ii + 19] = 1; 
&& !mx_0[ii - 21] 
mx_0[ii - 21] = 1; 
&& !mx_0[ii - 19] 
mx_0[ii - 19] = 1; 
&& !mx_0[ii + 21] 
mx_0[ii + 21] = 1; 
if ( mx_0[queue[k]] != 1 ) 
mx_0[queue[k]] = 0; 
fwrite( &unk_4DD750, 1uLL, 2uLL, outfile); 
v2 = &off_4DA70C; 
v2 = &off_4DA70C; 
v2 = &off_4DA70C + 2; 
v2 = &off_4DA70C + 2; 
v1 = v2; 
v1 = v2; 
gprintf( "%o%s:%1m ", v2, ( const char *)( unsigned int)stack[n]); 
v1 = ( void *__ptr32 *)( unsigned int)( count_variations - 1); 
gprintf( "%o ( variation %d)", v1, v0); 
gprintf( "%o\n", v1); 
gg_snprintf( result_0, 0x1DuLL, "[%d, %d, %d, %d]", e->a, e->b, e->c, e->d); 
gg_snprintf( result_0, 0x1DuLL, "%d%d%d%d", e->a, e->b, e->c, e->d); 
return result_0; 
v8 = ( const char *)&unk_4DD54F; 
liberties = findlib( str, 241, libs_1); 
pos = libs_1[k]; 
liberties = findlib( str, 241, libs_0); 
aa = libs_0[k]; 
bb = libs_0[k] + delta[l]; 
if ( *commanda == aHelp_1[0] ) 
if ( !gg_optind || !_getopt_initialized ) 
_getopt_initialized = 1; 
nextchar = ( char *)&unk_58C728; 
return gtp_success( &byte_4E1A32); 
return gtp_success( &byte_4E1A32); 
gtp_printf( &asc_4DDAB8[2]); 
gtp_printf( asc_4DDAB8); 
gtp_printf( &asc_4DDAB8[4]); 
routines[10] = ( const char *)&unk_4D6FAA; 
routines[11] = ( const char *)&unk_4D6FAA; 
routines[12] = ( const char *)&unk_4D6FAA; 
routines[13] = ( const char *)&unk_4D6FAA; 
routines[14] = ( const char *)&unk_4D6FAA; 
routines[15] = ( const char *)&unk_4D6FAA; 
*( float *)v3.m128i_i32 = Isis::UrlDb::GetFileName( &lower_bound, &upper_bound); 
v7 = ( _BYTE *)( &off_4E1420 + 2); 
v7 = ( const char *)&off_4E1420; 
if ( !init_1 ) 
location_to_buffer( pos_0, &buf_0[5 * pos_0]); 
init_1 = 1; 
init_owl( &owl_0, target, 0, 0, 1); 
owl_make_domains( owl_0, 0LL); 
prepare_goal_list( target, owl_0, owl_goal_worm, &goal_worms_computed, kworm, 1); 
result = do_owl_defend( target, &move, &wid, owl_0, 0, 0, 0); 
owl_0->goal, 
reason = ( const char *)&unk_4DB1CE; 
if ( color != current_color_1 ) 
current_color_1 = color; 
if ( board[pos] != 3 && board[pos] != current_board_0[pos] ) 
current_board_0[pos] = board[pos]; 
command = strtok( line_ptr, &byte_4E235E); 
gtp_main_loop( commands_0, gtp_input); 
*( float *)v4.m128i_i32 = Isis::UrlDb::GetFileName( &lower_bound, &upper_bound); 
gprintf( &byte_4D69ED); 
gprintf( off_4D69FE); 
if ( last_purge_position_number_0 != position_number ) 
last_purge_position_number_0 = position_number; 
if ( last_purge_position_number_1 != position_number ) 
last_purge_position_number_1 = position_number; 
v8 = ( const char *)&off_4D505A; 
v8 = ( const char *)&unk_4D505E; 
v9 = ( const char *)&off_4D505A; 
v9 = ( const char *)&unk_4D505E; 
v1 = ( const char *)&off_4D6806; 
if ( !initialized_0 ) 
initialized_0 = 1; 
memset( marked_3, 0, sizeof( marked_3)); 
memset( marked_3, 0, sizeof( marked_3)); 
if ( board[ii] != 3 && !marked_3[ii] && region_owner( q, ii) ) 
marked_3[ii] = 1; 
if ( board[tt + d] != 3 && !marked_3[tt + d] && color == region_owner( q, tt + d) ) 
marked_3[tt + d] = 1; 
owl_node_limit = 1000 * node_limits_0[10 - level] / node_limits_0[0]; 
owl_node_limit = 1000 * node_limits_0[10 - level] / node_limits_0[0]; 
v4 = off_58C41A; 
v4 = off_58C41A + 2; 
v4 = off_58C41A; 
v4 = off_58C41A + 2; 
sgf_dumptree = &local_tree_0; 
v6 = snames_2[dragon[posa].status]; 
v7 = snames_2[dragon[posa].crude_status]; 
v10 = &off_4D4BBC; 
v10 = &off_4D4BBC; 
v10 = &off_4D4BBC + 2; 
v10 = &off_4D4BBC + 2; 
v10, 
gprintf( ", owl status %s\n", snames_2[dragon[posa].owl_status]); 
if ( stone_count_for_position_2 != position_number ) 
white_stones_1 = 0; 
black_stones_0 = 0; 
++white_stones_1; 
++black_stones_0; 
stone_count_for_position_2 = position_number; 
v1 = black_stones_0; 
v2 = white_stones_1; 
